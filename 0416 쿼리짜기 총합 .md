# DATABASE 

- **체계화된 데이터의 모임**
- 논리적으로 연관된 자료의 모음으로 그 내용을 고도로 구조화 하여 검색과 갱신의 효율화를 꾀한 것
- **자료 파일을 조직적으로 통합**하여 **항목의 중복을 없애**고, **자료를 구조화**하여 기억시켜 놓은 **집합체**

<br>

- **데이터 측면 장점**
  - 중복 최소화
  - 무결성 : 기본키 의미 (RDB는 외래키)
  - 일관성 
  - 독립성 : 물리적 / 논리적
  - 표준화
  - 보안 유지

<br>

## RDB 관계형 데이터베이스

- Relational Database
- 관계형 모델에 기반
- 키와 값들의 간단한 관계를 표 형태로 정리한 데이터베이스

<br>

- **용어**

  ![제목 없음](https://user-images.githubusercontent.com/89068148/158102342-079a2fde-6346-4b35-941b-ec0d84a48b2b.png)

  - 스키마(schema) : 데이터베이스에서 자료구조, 표현, 관계 등 전반적인 명세를 기술
  - 테이블(table) : 열(컬럼,필드) 와 행(레코드,값)의 모델을 사용해 조직된 데이터 요소들의 집합

<br>

<br>

<br>

## Sqlite

- **Data Type**

  ```
  NULL
  INTEGET : 크기에 따라 0,1,2,3,4,6 또는 8바이트에 저장된 부호가 있는 정수
  REAR : 8바이트 부동 소수점 숫자로 저장된 부동 소수점 값
  TEXT
  BLOB : 입력된 그대로 정확히 저장된 데이터 (별도 타입 없음)
  ```

<br>

- **SQL 분류**

  | 분류 |                      개념                       |              예시               |
  | :--: | :---------------------------------------------: | :-----------------------------: |
  | DDL  | 관계형 데이터베이스 구조(테이블, 스키마)를 정의 |       CREATE, DROP, ALTER       |
  | DML  |         데이터를 저장, 조회, 수정, 삭제         | INSERT, SELECT, UPDATE, DELETE  |
  | DCL  |  데이터 베이스 사용자의 권한 제어를 위해 사용   | GRANT, REVOKE, COMMIT, ROLLBACK |

<br>

- **연습하는 방법**

  ```sqlite
  CSV 파일 다운로드
  $ sqlite3 tutorial.sqlite3
  sqlite> .database
  sqlite> .import hellodb.csv examples
  
  
  sqlite> .tables       # 테이블 목록 조회
  >>> examples examples2 examples3
  
  
  sqlite> .schema <테이블>      # 테이블 스키마 조회
  >>> 대상 테이블의 스키마 등장
  
  
  sqlite> SELECT * FROM examples;      # 특정 테이블의 레코드(행) 정보를 반환
  
  
  sqlite> CREATE TABLE testing1 (      # 테이블의 스키마 정의 및 테이블 생성
  	id INTEGER PRIMARY KEY,
      name TEXT
  );
  
  
  sqlite> DROP TABLE <테이블>;       # 대상 테이블 삭제
  
  
  sqlite> SELECT rowid, * FROM <테이블>;
  >>> 노출 안되던 id를 보여 준다.
      SQLite 는 따로 기본 키 속성의 칼럼을 작성하지 않으면 값이 자동으로 증가하는
      PK 옵션을 가진 rowid 컬럼을 정의
      
      
  CREATE TABLE classmates (
      id INTEGER PRIMARY KEY,    # 스키마에 id를 직접 작성하였으므로, 
      name TEXT NOT NULL,          넣고자 하는 데이터 값을 명시적으로 표현해야 함
      age INTEGER NOT NULL,      # 나머지 칼럼은 NOT NULL 이므로, 필수 인자
      address TEXT NOT NUL
  );
  
  
  INSERT INTO <테이블> VALUES     # 여러 값 추가
  (A1, A2, A3),
  (B1, B2, B3),
  (C1, C2, C3),
  (D1, D2, D3);
  ```

  ```sqlite
  분류 카테고리를 명시하는 법
  sqlite> .headers on
  
  이쁘게 구간 나눠서 표시
  sqlite> .mode column
  ```

<br>

- **쿼리 짜기**

  ```sqlite
  CREATE TABLE <테이블>
  
  DROP TABLE <테이블>
  
  INSERT INTO <테이블> (키1, 키2 ,,,) VALUES (값1, 값2 ,,,);   # 테이블에 단일 행 삽입
  INSERT INTO <테이블> VALUES("홍길동", 30, "서울");        # 모든 열의 데이터 있을 시 생략
  ```

<br>

- **SELECT와 함께 사용하는 clause**

  ```sqlite
  SELECT 컬럼1, 컬럼2, ... FROM <테이블> LIMIT 숫자;
  
  SELECT 컬럼1, 컬럼2, ... FROM <테이블> LIMIT 숫자 OFFSET 2; # 2칸만큼 제외하고 1개 조회
  
  SELECT 컬럼1, 컬럼2, ... FROM <테이블> WHERE 조건;
  
  SELECT DISTINCT 컬럼 FROM <테이블>;              # 특정 컬럼을 기준으로 중복없이 가져오기
  ```

<br>

- **DELETE**  행을 제거

  ```sqlite
  DELETE FROM <테이블> WHERE 조건;
  ```

  중복 불가능한 PK를 기준으로 삭제하는게 가장 좋다.

  이때 대상 PK는 기본적으로 재사용 된다.

  ex) DELETE FROM classmates WHERE rowid=5;

<br>

- **AUTOINCREMENT**(Column attribute) 사용하지 않거나 삭제된 행의 값 재사용 방지

  ```sqlite
  CREATE TABLE 테이블 (
  id INTEGER PRIMARY KEY AUTOINCREMENT, 
  ...
  );
  ```

  재사용 없이 사용하지 않았던 다음 행 값을 사용하게 된다.

<br>

- **UPDATE statement**

  ```sqlite
  UPDATE 테이블 SET 컬럼1=000, 컬럼2=000, ... WHERE 조건;
  ```

  중복 불가능한 rowid를 기준으로 사용하자
